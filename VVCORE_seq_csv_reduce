#!/Users/temporary/anaconda3/envs/VVCORE_dynasor/bin/python
import numpy as np
import time
import argparse

# Custom dependences
from VVCORElib_seq_csv import save_signal
from VVCORElib_seq_csv import compute_signal

def parser():
    """Parser of the arguments"""
    parser = argparse.ArgumentParser(description='VVCORE - autocorrelation function tool')
    parser.add_argument('-path', type=str, default='./', help='Path to the folder with trajectory')
    parser.add_argument('-i', type=str, default='data.dat', help='Input file with MD trajectory')
    parser.add_argument('-opt', type=str, default='dens cur_T cur_L', help='Program option')
    parser.add_argument('-N_frames', type=int, default=10000, help='Number of frames readed in one chunk')

    parser.add_argument('-lattice', type=str, choices = ['fcc', 'bcc', 'sc', 'file'], default='fcc', help='Lattice of the crystal (for none qubic set qpoints explitely in qpoint.h5 file)')
    parser.add_argument('-Nq_path', type=int, default=50, help='Number of q points to resolve (for cubic lattices) along path')
    parser.add_argument('-Nq', type=int, default=150, help='Total number of q points to resolve (for cubic lattices)')
    parser.add_argument('-a', type=float, default=None, help='Lattice constant for cubic lattices')
    parser.add_argument('-c', type=float, default=None, help='Lattice constant for hexagonal lattices')
    parser.add_argument('-M', type=str, default=None, help='Masses of the species')
    
    parser.add_argument('--partial', help='Option for computing all partial contributions', action='store_true')
    args = parser.parse_args()
    return args

if __name__ == "__main__":
    
    start_time_program = time.time()
    
    args = parser()

    path = args.path
    traj_file = f"{path}/{args.i}"
    opts = args.opt.split()

    N = args.N_frames

    lattice = args.lattice
    Nq_path = args.Nq_path
    Nq = args.Nq
    a = args.a
    c = args.c
    
    if not isinstance(args.M, type(None)):
        M = args.M.split()
        M = {str(i+1): np.float64(M[i]) for i in range(len(M))}
    
    partial = args.partial
    start_time_signal = time.time()
    #################  Compute signal part  #############################################3
    res, read_time, compute_time = compute_signal(traj_file, N, Nq_path, Nq, lattice, a, c, M, opts, partial)

    time_signal = time.time() - start_time_signal
    
    #################  Save signal part ################################
    start_time_comm_1 = time.time()
    
    for opt in opts:
        save_signal(res[opt], f"{path}/{opt}.h5")
        res.pop(opt)


    
    time_comm_1 = time.time() - start_time_comm_1
    time_program = time.time() - start_time_program
    
